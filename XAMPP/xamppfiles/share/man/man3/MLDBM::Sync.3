.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Sync 3"
.TH Sync 3 "2002-07-03" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\&  MLDBM::Sync \- safe concurrent access to MLDBM databases
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use MLDBM::Sync;                       # this gets the default, SDBM_File
\&  use MLDBM qw(DB_File Storable);        # use Storable for serializing
\&  use MLDBM qw(MLDBM::Sync::SDBM_File);  # use extended SDBM_File, handles values > 1024 bytes
\&  use Fcntl qw(:DEFAULT);                # import symbols O_CREAT & O_RDWR for use with DBMs
\&
\&  # NORMAL PROTECTED read/write with implicit locks per i/o request
\&  my $sync_dbm_obj = tie %cache, \*(AqMLDBM::Sync\*(Aq [..other DBM args..] or die $!;
\&  $cache{"AAAA"} = "BBBB";
\&  my $value = $cache{"AAAA"};
\&
\&  # SERIALIZED PROTECTED read/write with explicit lock for both i/o requests
\&  my $sync_dbm_obj = tie %cache, \*(AqMLDBM::Sync\*(Aq, \*(Aq/tmp/syncdbm\*(Aq, O_CREAT|O_RDWR, 0640;
\&  $sync_dbm_obj\->Lock;
\&  $cache{"AAAA"} = "BBBB";
\&  my $value = $cache{"AAAA"};
\&  $sync_dbm_obj\->UnLock;
\&
\&  # SERIALIZED PROTECTED READ access with explicit read lock for both reads
\&  $sync_dbm_obj\->ReadLock;
\&  my @keys = keys %cache;
\&  my $value = $cache{\*(AqAAAA\*(Aq};
\&  $sync_dbm_obj\->UnLock;
\&
\&  # MEMORY CACHE LAYER with Tie::Cache
\&  $sync_dbm_obj\->SyncCacheSize(\*(Aq100K\*(Aq);
\&
\&  # KEY CHECKSUMS, for lookups on MD5 checksums on large keys
\&  my $sync_dbm_obj = tie %cache, \*(AqMLDBM::Sync\*(Aq, \*(Aq/tmp/syncdbm\*(Aq, O_CREAT|O_RDWR, 0640;
\&  $sync_dbm_obj\->SyncKeysChecksum(1);
\&  my $large_key = "KEY" x 10000;
\&  $sync{$large_key} = "LARGE";
\&  my $value = $sync{$large_key};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module wraps around the \s-1MLDBM\s0 interface, by handling concurrent
access to \s-1MLDBM\s0 databases with file locking, and flushes i/o explicity
per lock/unlock.  The new [Read]\fILock()\fR/\fIUnLock()\fR \s-1API\s0 can be used to serialize
requests logically and improve performance for bundled reads & writes.
.PP
.Vb 1
\&  my $sync_dbm_obj = tie %cache, \*(AqMLDBM::Sync\*(Aq, \*(Aq/tmp/syncdbm\*(Aq, O_CREAT|O_RDWR, 0640;
\&
\&  # Write locked critical section
\&  $sync_dbm_obj\->Lock;
\&    ... all accesses to DBM LOCK_EX protected, and go to same tied file handles
\&    $cache{\*(AqKEY\*(Aq} = \*(AqVALUE\*(Aq;
\&  $sync_dbm_obj\->UnLock;
\&
\&  # Read locked critical section
\&  $sync_dbm_obj\->ReadLock;
\&    ... all read accesses to DBM LOCK_SH protected, and go to same tied files
\&    ... WARNING, cannot write to DBM in ReadLock() section, will die()
\&    ... WARNING, my $v = $cache{\*(AqKEY\*(Aq}{\*(AqSUBKEY\*(Aq} will trigger a write so not safe
\&    ...   to use in ReadLock() section
\&    my $value = $cache{\*(AqKEY\*(Aq};
\&  $sync_dbm_obj\->UnLock;
\&
\&  # Normal access OK too, without explicity locking
\&  $cache{\*(AqKEY\*(Aq} = \*(AqVALUE\*(Aq;
\&  my $value = $cache{\*(AqKEY\*(Aq};
.Ve
.PP
\&\s-1MLDBM\s0 continues to serve as the underlying \s-1OO\s0 layer that
serializes complex data structures to be stored in the databases.
See the \s-1MLDBM\s0 \s-1BUGS\s0 section for important limitations.
.PP
MLDBM::Sync also provides built in \s-1RAM\s0 caching with Tie::Cache
md5 key checksum functionality.
.SH "INSTALL"
.IX Header "INSTALL"
Like any other \s-1CPAN\s0 module, either use \s-1CPAN\s0.pm, or perl \-MCPAN \f(CW\*(C`\-e\*(C'\fR shell,
or get the file MLDBM\-Sync\-x.xx.tar.gz, unzip, untar and:
.PP
.Vb 4
\&  perl Makefile.PL
\&  make
\&  make test
\&  make install
.Ve
.SH "LOCKING"
.IX Header "LOCKING"
The MLDBM::Sync wrapper protects \s-1MLDBM\s0 databases by locking
and unlocking around read and write requests to the databases.
Also necessary is for each new lock to \fItie()\fR to the database
internally, \fIuntie()\fRing when unlocking.  This flushes any
i/o for the dbm to the operating system, and allows for
concurrent read/write access to the databases.
.PP
Without any extra effort from the developer, an existing 
\&\s-1MLDBM\s0 database will benefit from MLDBM::sync.
.PP
.Vb 2
\&  my $dbm_obj = tie %dbm, ...;
\&  $dbm{"key"} = "value";
.Ve
.PP
As a write or \s-1STORE\s0 operation, the above will automatically
cause the following:
.PP
.Vb 3
\&  $dbm_obj\->Lock; # also ties
\&  $dbm{"key"} = "value";
\&  $dbm_obj\->UnLock; # also unties
.Ve
.PP
Just so, a read or \s-1FETCH\s0 operation like:
.PP
.Vb 1
\&  my $value = $dbm{"key"};
.Ve
.PP
will really trigger:
.PP
.Vb 3
\&  $dbm_obj\->ReadLock; # also ties
\&  my $value = $dbm{"key"};
\&  $dbm_obj\->Lock; # also unties
.Ve
.PP
However, these lock operations are expensive because of the 
underlying \fItie()\fR/\fIuntie()\fR that occurs for i/o flushing, so 
when bundling reads & writes, a developer may explicitly
use this \s-1API\s0 for greater performance:
.PP
.Vb 7
\&  # tie once to database, write 100 times
\&  $dbm_obj\->Lock;
\&  for (1..100) {
\&    $dbm{$_} = $_ * 100;
\&    ...
\&  }
\&  $dbm_obj\->UnLock;
\&
\&  # only tie once to database, and read 100 times
\&  $dbm_obj\->ReadLock;
\&  for(1..100) {
\&    my $value = $dbm{$_};  
\&    ...
\&  }
\&  $dbm_obj\->UnLock;
.Ve
.SH "CACHING"
.IX Header "CACHING"
I built MLDBM::Sync to serve as a fast and robust caching layer
for use in multi-process environments like mod_perl.  In order
to provide an additional speed boost when caching static data,
I have added an \s-1RAM\s0 caching layer with Tie::Cache, which 
regulates the size of the memory used with its MaxBytes setting.
.PP
To activate this caching, just:
.PP
.Vb 4
\&  my $dbm = tie %cache, \*(AqMLDBM::Sync\*(Aq, \*(Aq/tmp/syncdbm\*(Aq, O_CREAT|O_RDWR, 0640;
\&  $dbm\->SyncCacheSize(100000);  # 100000 bytes max memory used
\&  $dbm\->SyncCacheSize(\*(Aq100K\*(Aq);  # 100 Kbytes max memory used
\&  $dbm\->SyncCacheSize(\*(Aq1M\*(Aq);    # 1 Megabyte max memory used
.Ve
.PP
The ./bench/bench_sync.pl, run like "bench_sync.pl \f(CW\*(C`\-c\*(C'\fR" will run 
the tests with caching turned on creating a benchmark with 50%
cache hits.
.PP
One run without caching was:
.PP
.Vb 5
\& === INSERT OF 50 BYTE RECORDS ===
\&  Time for 100 writes + 100 reads for  SDBM_File                  0.16 seconds     12288 bytes
\&  Time for 100 writes + 100 reads for  MLDBM::Sync::SDBM_File     0.17 seconds     12288 bytes
\&  Time for 100 writes + 100 reads for  GDBM_File                  3.37 seconds     17980 bytes
\&  Time for 100 writes + 100 reads for  DB_File                    4.45 seconds     20480 bytes
.Ve
.PP
And with caching, with 50% cache hits:
.PP
.Vb 5
\& === INSERT OF 50 BYTE RECORDS ===
\&  Time for 100 writes + 100 reads for  SDBM_File                  0.11 seconds     12288 bytes
\&  Time for 100 writes + 100 reads for  MLDBM::Sync::SDBM_File     0.11 seconds     12288 bytes
\&  Time for 100 writes + 100 reads for  GDBM_File                  2.49 seconds     17980 bytes
\&  Time for 100 writes + 100 reads for  DB_File                    2.55 seconds     20480 bytes
.Ve
.PP
Even for SDBM_File, this speedup is near 33%.
.SH "KEYS CHECKSUM"
.IX Header "KEYS CHECKSUM"
A common operation on database lookups is checksumming
the key, prior to the lookup, because the key could be
very large, and all one really wants is the data it maps
too.  To enable this functionality automatically with 
MLDBM::Sync, just:
.PP
.Vb 2
\&  my $sync_dbm_obj = tie %cache, \*(AqMLDBM::Sync\*(Aq, \*(Aq/tmp/syncdbm\*(Aq, O_CREAT|O_RDWR, 0640;
\&  $sync_dbm_obj\->SyncKeysChecksum(1);
\&
\& !! WARNING: keys() & each() do not work on these databases
\& !! as of v.03, so the developer will not be fooled into thinking
\& !! the stored key values are meaningful to the calling application 
\& !! and will die() if called.
\& !!
\& !! This behavior could be relaxed in the future.
.Ve
.PP
An example of this might be to cache a \s-1XSLT\s0 conversion,
which are typically very expensive.  You have the 
\&\s-1XML\s0 data and the \s-1XSLT\s0 data, so all you do is:
.PP
.Vb 6
\&  # $xml_data, $xsl_data are strings
\&  my $xslt_output;
\&  unless ($xslt_output = $cache{$xml_data.\*(Aq&&&&\*(Aq.$xsl_data}) {
\&    ... do XSLT conversion here for $xslt_output ...
\&    $cache{$xml_data.\*(Aq&&&&\*(Aq.xsl_data} = $xslt_output;
\&  }
.Ve
.PP
What you save by doing this is having to create \s-1HUGE\s0 keys
to lookup on, which no \s-1DBM\s0 is likely to do efficiently.
This is the same method that File::Cache uses internally to 
hash its file lookups in its directories.
.SH "New MLDBM::Sync::SDBM_File"
.IX Header "New MLDBM::Sync::SDBM_File"
SDBM_File, the default used for \s-1MLDBM\s0 and therefore MLDBM::Sync 
has a limit of 1024 bytes for the size of a record.
.PP
SDBM_File is also an order of magnitude faster for small records
to use with MLDBM::Sync, than DB_File or GDBM_File, because the
\&\fItie()\fR/\fIuntie()\fR to the dbm is much faster.  Therefore,
bundled with MLDBM::Sync release is a MLDBM::Sync::SDBM_File
layer which works around this 1024 byte limit.  To use, just:
.PP
.Vb 1
\&  use MLDBM qw(MLDBM::Sync::SDBM_File);
.Ve
.PP
It works by breaking up up the \s-1\fISTORE\s0()\fR values into small 128 
byte segments, and spreading those segments across many records,
creating a virtual record layer.  It also uses Compress::Zlib
to compress \s-1STORED\s0 data, reducing the number of these 128 byte 
records. In benchmarks, 128 byte record segments seemed to be a
sweet spot for space/time efficiency, as SDBM_File created
very bloated *.pag files for 128+ byte records.
.SH "BENCHMARKS"
.IX Header "BENCHMARKS"
In the distribution ./bench directory is a bench_sync.pl script
that can benchmark using the various DBMs with MLDBM::Sync.
.PP
The MLDBM::Sync::SDBM_File \s-1DBM\s0 is special because is uses 
SDBM_File for fast small inserts, but slows down linearly
with the size of the data being inserted and read.
.PP
The results for a dual \s-1PIII\-450\s0 linux 2.4.7, with a ext3 file system 
blocksize 4096 mounted async on a \s-1RAID\-1\s0 2xIDE 7200 \s-1RPM\s0 disk were as follows:
.PP
.Vb 6
\& === INSERT OF 50 BYTE RECORDS ===
\&  Time for 100 writes + 100 reads for  SDBM_File                  0.16 seconds     12288 bytes
\&  Time for 100 writes + 100 reads for  MLDBM::Sync::SDBM_File     0.19 seconds     12288 bytes
\&  Time for 100 writes + 100 reads for  GDBM_File                  1.09 seconds     18066 bytes
\&  Time for 100 writes + 100 reads for  DB_File                    0.67 seconds     12288 bytes
\&  Time for 100 writes + 100 reads for  Tie::TextDir .04           0.31 seconds     13192 bytes
\&
\& === INSERT OF 500 BYTE RECORDS ===
\& (skipping test for SDBM_File 100 byte limit)
\&  Time for 100 writes + 100 reads for  MLDBM::Sync::SDBM_File     0.52 seconds    110592 bytes
\&  Time for 100 writes + 100 reads for  GDBM_File                  1.20 seconds     63472 bytes
\&  Time for 100 writes + 100 reads for  DB_File                    0.66 seconds     86016 bytes
\&  Time for 100 writes + 100 reads for  Tie::TextDir .04           0.32 seconds     58192 bytes
\&
\& === INSERT OF 5000 BYTE RECORDS ===
\& (skipping test for SDBM_File 100 byte limit)
\&  Time for 100 writes + 100 reads for  MLDBM::Sync::SDBM_File     1.41 seconds   1163264 bytes
\&  Time for 100 writes + 100 reads for  GDBM_File                  1.38 seconds    832400 bytes
\&  Time for 100 writes + 100 reads for  DB_File                    1.21 seconds    831488 bytes
\&  Time for 100 writes + 100 reads for  Tie::TextDir .04           0.58 seconds    508192 bytes
\&
\& === INSERT OF 20000 BYTE RECORDS ===
\& (skipping test for SDBM_File 100 byte limit)
\& (skipping test for MLDBM::Sync db size > 1M)
\&  Time for 100 writes + 100 reads for  GDBM_File                  2.23 seconds   2063912 bytes
\&  Time for 100 writes + 100 reads for  DB_File                    1.89 seconds   2060288 bytes
\&  Time for 100 writes + 100 reads for  Tie::TextDir .04           1.26 seconds   2008192 bytes
\&
\& === INSERT OF 50000 BYTE RECORDS ===
\& (skipping test for SDBM_File 100 byte limit)
\& (skipping test for MLDBM::Sync db size > 1M)
\&  Time for 100 writes + 100 reads for  GDBM_File                  3.66 seconds   5337944 bytes
\&  Time for 100 writes + 100 reads for  DB_File                    3.64 seconds   5337088 bytes
\&  Time for 100 writes + 100 reads for  Tie::TextDir .04           2.80 seconds   5008192 bytes
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Copyright (c) 2001\-2002 Joshua Chamas, Chamas Enterprises Inc.  All rights reserved.
Sponsored by development on NodeWorks http://www.nodeworks.com and Apache::ASP
http://www.apache\-asp.org
.PP
This program is free software; you can redistribute it
and/or modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 1
\& MLDBM(3), SDBM_File(3), DB_File(3), GDBM_File(3)
.Ve
